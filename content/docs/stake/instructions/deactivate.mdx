---
title: Deactivate
description: Begin the deactivation cooldown process for delegated stake.
---

## Overview

| Property | Value |
|----------|-------|
| Instruction Index | 5 |
| Estimated CU | ~10,600 |

The `Deactivate` instruction initiates the cooldown process for stake. Once deactivation completes (after one or more epochs), the stake can be withdrawn.

## Accounts

| Index | Name | Writable | Signer | Description |
|-------|------|----------|--------|-------------|
| 0 | Stake Account | ✅ | ❌ | The stake account to deactivate |
| 1 | Clock Sysvar | ❌ | ❌ | `SysvarC1ock11111111111111111111111111111111` |
| 2 | Stake Authority | ❌ | ✅ | Stake authority must sign |

## Arguments

None.

## Behavior

1. Validates stake account is currently delegated (activating or active)
2. Sets `deactivation_epoch` to current epoch
3. Stake begins cooling down at the next epoch boundary
4. During cooldown, stake continues earning rewards proportional to effective stake

## Cooldown Duration

The cooldown period depends on network conditions:
- **Typical**: 1-4 epochs (2-12 days on mainnet)
- **High deactivation volume**: May extend longer

## Examples

### TypeScript (web3.js v1)

```typescript
import {
  Connection,
  PublicKey,
  Transaction,
  StakeProgram,
  sendAndConfirmTransaction,
} from '@solana/web3.js';

const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

const stakeAccountPubkey = new PublicKey('...');
const stakeAuthority = /* Keypair */;

const deactivateIx = StakeProgram.deactivate({
  stakePubkey: stakeAccountPubkey,
  authorizedPubkey: stakeAuthority.publicKey,
});

const tx = new Transaction().add(deactivateIx);

const signature = await sendAndConfirmTransaction(connection, tx, [
  payer,
  stakeAuthority,
]);

console.log('Deactivation initiated:', signature);
```

### TypeScript (@solana-program/stake)

```typescript
import { getDeactivateInstruction } from '@solana-program/stake';
import { CLOCK_SYSVAR_ADDRESS } from '@solana/kit';

const deactivateIx = getDeactivateInstruction({
  stakeAccount: stakeAccountAddress,
  stakeAuthority: stakeAuthoritySigner,
  clock: CLOCK_SYSVAR_ADDRESS,
});
```

### Rust

```rust
use solana_sdk::{
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    stake::instruction as stake_instruction,
    transaction::Transaction,
};

fn deactivate_stake(
    client: &RpcClient,
    payer: &Keypair,
    stake_account: &Pubkey,
    stake_authority: &Keypair,
) -> Result<(), Box<dyn std::error::Error>> {
    let deactivate_ix = stake_instruction::deactivate_stake(
        stake_account,
        &stake_authority.pubkey(),
    );

    let recent_blockhash = client.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &[deactivate_ix],
        Some(&payer.pubkey()),
        &[payer, stake_authority],
        recent_blockhash,
    );

    client.send_and_confirm_transaction(&tx)?;
    Ok(())
}
```

### CLI

```bash
# Deactivate stake
solana deactivate-stake <STAKE_ACCOUNT_ADDRESS>

# With explicit stake authority
solana deactivate-stake <STAKE_ACCOUNT_ADDRESS> \
  --stake-authority <STAKE_AUTHORITY_KEYPAIR>
```

## Monitoring Deactivation

```typescript
async function monitorDeactivation(
  connection: Connection,
  stakeAccount: PublicKey
) {
  const activation = await connection.getStakeActivation(stakeAccount);
  
  if (activation.state === 'deactivating') {
    const totalStake = activation.active + activation.inactive;
    const progress = (activation.inactive / totalStake) * 100;
    console.log(`Deactivation progress: ${progress.toFixed(1)}%`);
    console.log(`Active: ${activation.active}, Inactive: ${activation.inactive}`);
  } else if (activation.state === 'inactive') {
    console.log('Deactivation complete! Ready for withdrawal.');
  }
}
```

## Errors

| Error | Cause |
|-------|-------|
| `InvalidAccountData` | Stake account not delegated |
| `AlreadyDeactivated` | Stake already deactivating or deactivated |

---

# DeactivateDelinquent

Permissionless deactivation of stake delegated to delinquent validators.

## Overview

| Property | Value |
|----------|-------|
| Instruction Index | 14 |
| Estimated CU | ~11,400 |

This instruction allows anyone to deactivate stake that is delegated to a validator that has been delinquent (not voting) for an extended period. No signature from the stake authority is required.

## Purpose

`DeactivateDelinquent` serves as a network health mechanism:
- Protects delegators from validators that have gone offline
- Enables stake to be recovered without stake authority action
- Promotes network decentralization by moving stake away from inactive validators

## Accounts

| Index | Name | Writable | Signer | Description |
|-------|------|----------|--------|-------------|
| 0 | Stake Account | ✅ | ❌ | The stake account to deactivate |
| 1 | Vote Account | ❌ | ❌ | The delinquent validator's vote account |
| 2 | Reference Vote Account | ❌ | ❌ | A vote account that has voted recently |
| 3 | Clock Sysvar | ❌ | ❌ | `SysvarC1ock11111111111111111111111111111111` |

## Arguments

None.

## Delinquency Threshold

A validator is considered delinquent if they have not voted in the last **5 epochs** (approximately 10-15 days on mainnet).

```rust
const MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION: u64 = 5;
```

## Reference Vote Account

The reference vote account proves that voting is possible on the network. It must have voted within the delinquency threshold. This prevents false positives during network issues.

## Examples

### TypeScript

```typescript
import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SYSVAR_CLOCK_PUBKEY,
} from '@solana/web3.js';

const STAKE_PROGRAM_ID = new PublicKey('Stake11111111111111111111111111111111111111');

async function deactivateDelinquent(
  connection: Connection,
  stakeAccount: PublicKey,
  delinquentVoteAccount: PublicKey,
  referenceVoteAccount: PublicKey,
) {
  // Instruction index 14 = DeactivateDelinquent
  const data = Buffer.alloc(4);
  data.writeUInt32LE(14, 0);

  const ix = new TransactionInstruction({
    keys: [
      { pubkey: stakeAccount, isSigner: false, isWritable: true },
      { pubkey: delinquentVoteAccount, isSigner: false, isWritable: false },
      { pubkey: referenceVoteAccount, isSigner: false, isWritable: false },
      { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
    ],
    programId: STAKE_PROGRAM_ID,
    data,
  });

  const tx = new Transaction().add(ix);
  return tx;
}
```

### Finding Delinquent Validators

```typescript
async function findDelinquentValidators(connection: Connection) {
  const { current, delinquent } = await connection.getVoteAccounts();
  
  console.log('Active validators:', current.length);
  console.log('Delinquent validators:', delinquent.length);
  
  // Delinquent validators with significant stake
  const significantDelinquent = delinquent.filter(
    v => v.activatedStake > 1_000_000_000_000 // > 1000 SOL
  );
  
  for (const validator of significantDelinquent) {
    console.log('Delinquent:', validator.votePubkey);
    console.log('  Stake:', validator.activatedStake / 1e9, 'SOL');
    console.log('  Last Vote:', validator.lastVote);
  }
  
  return delinquent;
}
```

### Finding Reference Vote Account

```typescript
async function findReferenceVoteAccount(connection: Connection) {
  const { current } = await connection.getVoteAccounts();
  
  // Use a highly active validator as reference
  const sorted = current.sort((a, b) => b.lastVote - a.lastVote);
  
  if (sorted.length > 0) {
    return new PublicKey(sorted[0].votePubkey);
  }
  
  throw new Error('No active validators found');
}
```

## Errors

| Error | Cause |
|-------|-------|
| `InsufficientDelinquentEpochs` | Validator hasn't been delinquent long enough |
| `InvalidAccountData` | Stake not delegated to the specified vote account |
| `ReferenceVoteAccountNotVoted` | Reference vote account is also delinquent |

## Use Cases

1. **Automated Stake Management**: Bots can monitor and deactivate stakes from delinquent validators
2. **Custodial Services**: Protect client stakes without requiring their signatures
3. **Network Health**: Community members can help clean up abandoned delegations

## Security Considerations

- This instruction cannot be used maliciously against active validators
- The 5-epoch threshold provides validators time to recover from temporary issues
- Delegators should still monitor their stakes and proactively manage delegations

---
title: Split and Merge
description: Split stake accounts into multiple accounts or merge them together.
---

## Overview

| Property | Value |
|----------|-------|
| Instruction Index | 3 |
| Estimated CU | ~16,900 |

The `Split` instruction creates a new stake account with a portion of the source account's funds. The new account inherits the delegation state of the source.

## Accounts

| Index | Name | Writable | Signer | Description |
|-------|------|----------|--------|-------------|
| 0 | Source Stake Account | ✅ | ❌ | Account to split from |
| 1 | New Stake Account | ✅ | ❌ | Destination for split funds |
| 2 | Stake Authority | ❌ | ✅ | Stake authority must sign |

## Arguments

| Field | Type | Description |
|-------|------|-------------|
| `lamports` | u64 | Amount to transfer to new account |

## Constraints

Both the source and destination accounts must maintain valid balances:

```
minimum_balance = rent_exempt_reserve + minimum_delegation

// Source must retain at least:
source_remaining >= rent_exempt_reserve + minimum_delegation (if delegated)
source_remaining >= rent_exempt_reserve (if not delegated)

// Destination must receive at least:
split_amount >= rent_exempt_reserve + minimum_delegation (if delegated)
split_amount >= rent_exempt_reserve (if not delegated)
```

## Behavior

1. Validates source is initialized or staked
2. Validates destination is uninitialized with correct size
3. Copies meta (authorities, lockup) to destination
4. If delegated, copies delegation info to destination
5. Transfers specified lamports from source to destination

## Examples

### TypeScript (web3.js v1)

```typescript
import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  StakeProgram,
  LAMPORTS_PER_SOL,
  sendAndConfirmTransaction,
} from '@solana/web3.js';

const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

const sourceStake = new PublicKey('...');
const stakeAuthority = /* Keypair */;
const newStakeAccount = Keypair.generate();

// Get rent-exempt minimum
const rentExempt = await connection.getMinimumBalanceForRentExemption(
  StakeProgram.space
);

// Amount to split (must cover rent + minimum delegation)
const splitAmount = rentExempt + 2 * LAMPORTS_PER_SOL;

// Create the new stake account first
const createAccountIx = SystemProgram.createAccount({
  fromPubkey: payer.publicKey,
  newAccountPubkey: newStakeAccount.publicKey,
  lamports: 0, // Will receive funds from split
  space: StakeProgram.space,
  programId: StakeProgram.programId,
});

// Split instruction
const splitIx = StakeProgram.split({
  stakePubkey: sourceStake,
  authorizedPubkey: stakeAuthority.publicKey,
  splitStakePubkey: newStakeAccount.publicKey,
  lamports: splitAmount,
});

const tx = new Transaction().add(createAccountIx, splitIx);

const signature = await sendAndConfirmTransaction(connection, tx, [
  payer,
  stakeAuthority,
  newStakeAccount,
]);

console.log('Split complete:', signature);
console.log('New stake account:', newStakeAccount.publicKey.toBase58());
```

### TypeScript (@solana-program/stake)

```typescript
import { 
  getSplitInstruction,
  STAKE_ACCOUNT_SIZE,
  STAKE_PROGRAM_ADDRESS,
} from '@solana-program/stake';
import { getCreateAccountInstruction, lamports } from '@solana/kit';

const rentExempt = await rpc.getMinimumBalanceForRentExemption(STAKE_ACCOUNT_SIZE).send();
const splitAmount = rentExempt + 2_000_000_000n; // rent + 2 SOL

const instructions = [
  getCreateAccountInstruction({
    payer,
    newAccount: newStakeAccountSigner,
    lamports: lamports(0n),
    space: STAKE_ACCOUNT_SIZE,
    programAddress: STAKE_PROGRAM_ADDRESS,
  }),
  getSplitInstruction({
    sourceStakeAccount: sourceStakeAddress,
    destinationStakeAccount: newStakeAccountSigner.address,
    stakeAuthority: stakeAuthoritySigner,
    lamports: lamports(splitAmount),
  }),
];
```

### Rust

```rust
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    stake::instruction as stake_instruction,
    system_instruction,
    transaction::Transaction,
};

fn split_stake(
    client: &RpcClient,
    payer: &Keypair,
    source_stake: &Pubkey,
    stake_authority: &Keypair,
    split_amount: u64,
) -> Result<Pubkey, Box<dyn std::error::Error>> {
    let new_stake = Keypair::new();
    
    let rent_exempt = client.get_minimum_balance_for_rent_exemption(
        std::mem::size_of::<solana_sdk::stake::state::StakeStateV2>()
    )?;

    let instructions = vec![
        system_instruction::create_account(
            &payer.pubkey(),
            &new_stake.pubkey(),
            0, // Will receive from split
            std::mem::size_of::<solana_sdk::stake::state::StakeStateV2>() as u64,
            &solana_sdk::stake::program::id(),
        ),
        stake_instruction::split(
            source_stake,
            &stake_authority.pubkey(),
            split_amount,
            &new_stake.pubkey(),
        )[0].clone(),
    ];

    let recent_blockhash = client.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &instructions,
        Some(&payer.pubkey()),
        &[payer, stake_authority, &new_stake],
        recent_blockhash,
    );

    client.send_and_confirm_transaction(&tx)?;
    Ok(new_stake.pubkey())
}
```

### CLI

```bash
# Split 5 SOL into a new stake account
solana split-stake <SOURCE_STAKE_ADDRESS> <NEW_STAKE_KEYPAIR> 5

# With explicit stake authority
solana split-stake <SOURCE_STAKE_ADDRESS> <NEW_STAKE_KEYPAIR> 5 \
  --stake-authority <STAKE_AUTHORITY_KEYPAIR>
```

## Use Cases

1. **Partial Withdrawal**: Split inactive portion for withdrawal while keeping active stake
2. **Diversification**: Split stake to delegate to multiple validators
3. **Liquidity Management**: Access a portion of stake without fully deactivating

---

# Merge

Merge two stake accounts into one.

## Overview

| Property | Value |
|----------|-------|
| Instruction Index | 7 |
| Estimated CU | ~17,600 |

The `Merge` instruction combines two stake accounts. The source account's balance is added to the destination, and the source account is closed.

## Accounts

| Index | Name | Writable | Signer | Description |
|-------|------|----------|--------|-------------|
| 0 | Destination Stake Account | ✅ | ❌ | Account to receive merged stake |
| 1 | Source Stake Account | ✅ | ❌ | Account to merge from (will be closed) |
| 2 | Clock Sysvar | ❌ | ❌ | `SysvarC1ock11111111111111111111111111111111` |
| 3 | Stake History | ❌ | ❌ | `SysvarStakeHistory1111111111111111111111111` |
| 4 | Stake Authority | ❌ | ✅ | Stake authority must sign |

## Arguments

None.

## Merge Compatibility

Both accounts must have:
- Same stake authority
- Same withdraw authority
- Same lockup parameters

### State Compatibility Matrix

| Source State | Destination State | Compatible? |
|--------------|-------------------|-------------|
| Inactive | Inactive | ✅ Yes |
| Inactive | Activating | ✅ Yes |
| Inactive | Active (same epoch) | ✅ Yes |
| Activating | Activating (same epoch) | ✅ Yes |
| Active | Active (same epoch) | ✅ Yes |
| Deactivating | * | ❌ No |
| * | Deactivating | ❌ No |

### Additional Requirements

When both accounts are delegated:
- Must be delegated to the same validator
- Must have the same activation epoch

## Examples

### TypeScript (web3.js v1)

```typescript
import {
  Connection,
  PublicKey,
  Transaction,
  StakeProgram,
  sendAndConfirmTransaction,
} from '@solana/web3.js';

const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

const destinationStake = new PublicKey('...');
const sourceStake = new PublicKey('...');
const stakeAuthority = /* Keypair */;

const mergeIx = StakeProgram.merge({
  stakePubkey: destinationStake,
  sourceStakePubkey: sourceStake,
  authorizedPubkey: stakeAuthority.publicKey,
});

const tx = new Transaction().add(mergeIx);

const signature = await sendAndConfirmTransaction(connection, tx, [
  payer,
  stakeAuthority,
]);

console.log('Merge complete:', signature);
// Source account is now closed
// Destination account has combined balance
```

### TypeScript (@solana-program/stake)

```typescript
import { getMergeInstruction } from '@solana-program/stake';
import { 
  CLOCK_SYSVAR_ADDRESS, 
  STAKE_HISTORY_SYSVAR_ADDRESS 
} from '@solana/kit';

const mergeIx = getMergeInstruction({
  destinationStakeAccount: destinationStakeAddress,
  sourceStakeAccount: sourceStakeAddress,
  stakeAuthority: stakeAuthoritySigner,
  clock: CLOCK_SYSVAR_ADDRESS,
  stakeHistory: STAKE_HISTORY_SYSVAR_ADDRESS,
});
```

### Rust

```rust
use solana_sdk::{
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    stake::instruction as stake_instruction,
    transaction::Transaction,
};

fn merge_stakes(
    client: &RpcClient,
    payer: &Keypair,
    destination_stake: &Pubkey,
    source_stake: &Pubkey,
    stake_authority: &Keypair,
) -> Result<(), Box<dyn std::error::Error>> {
    let merge_ix = stake_instruction::merge(
        destination_stake,
        source_stake,
        &stake_authority.pubkey(),
    )[0].clone();

    let recent_blockhash = client.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &[merge_ix],
        Some(&payer.pubkey()),
        &[payer, stake_authority],
        recent_blockhash,
    );

    client.send_and_confirm_transaction(&tx)?;
    Ok(())
}
```

### CLI

```bash
# Merge source into destination
solana merge-stake <DESTINATION_STAKE_ADDRESS> <SOURCE_STAKE_ADDRESS>

# With explicit stake authority
solana merge-stake <DESTINATION_STAKE_ADDRESS> <SOURCE_STAKE_ADDRESS> \
  --stake-authority <STAKE_AUTHORITY_KEYPAIR>
```

## Checking Merge Eligibility

```typescript
async function canMerge(
  connection: Connection,
  destination: PublicKey,
  source: PublicKey,
): Promise<{ eligible: boolean; reason?: string }> {
  const [destInfo, srcInfo] = await Promise.all([
    connection.getParsedAccountInfo(destination),
    connection.getParsedAccountInfo(source),
  ]);

  const destData = destInfo.value?.data.parsed.info;
  const srcData = srcInfo.value?.data.parsed.info;

  // Check authorities match
  if (destData.meta.authorized.staker !== srcData.meta.authorized.staker) {
    return { eligible: false, reason: 'Stake authorities differ' };
  }
  if (destData.meta.authorized.withdrawer !== srcData.meta.authorized.withdrawer) {
    return { eligible: false, reason: 'Withdraw authorities differ' };
  }

  // Check lockup matches
  const destLockup = destData.meta.lockup;
  const srcLockup = srcData.meta.lockup;
  if (JSON.stringify(destLockup) !== JSON.stringify(srcLockup)) {
    return { eligible: false, reason: 'Lockup parameters differ' };
  }

  // Check activation states
  const [destActivation, srcActivation] = await Promise.all([
    connection.getStakeActivation(destination),
    connection.getStakeActivation(source),
  ]);

  if (destActivation.state === 'deactivating' || srcActivation.state === 'deactivating') {
    return { eligible: false, reason: 'Cannot merge deactivating stakes' };
  }

  // Check delegation matches if both are staked
  if (destData.stake && srcData.stake) {
    if (destData.stake.delegation.voter !== srcData.stake.delegation.voter) {
      return { eligible: false, reason: 'Delegated to different validators' };
    }
  }

  return { eligible: true };
}
```

## Errors

| Error | Cause |
|-------|-------|
| `MergeMismatch` | Accounts have different authorities or lockups |
| `InvalidAccountData` | One or both accounts not valid stake accounts |
| `MergeTransientStake` | Cannot merge deactivating stake |
| `NotDelegated` | Attempting to merge stakes with different validators |

---
title: Merge
description: Merge two stake accounts into one.
---

## Overview

| Property | Value |
|----------|-------|
| Instruction Index | 7 |
| Estimated CU | ~17,600 |

The `Merge` instruction combines two stake accounts. The source account's balance is added to the destination, and the source account is closed.

## Accounts

| Index | Name | Writable | Signer | Description |
|-------|------|----------|--------|-------------|
| 0 | Destination Stake Account | ✅ | ❌ | Account to receive merged stake |
| 1 | Source Stake Account | ✅ | ❌ | Account to merge from (will be closed) |
| 2 | Clock Sysvar | ❌ | ❌ | `SysvarC1ock11111111111111111111111111111111` |
| 3 | Stake History | ❌ | ❌ | `SysvarStakeHistory1111111111111111111111111` |
| 4 | Stake Authority | ❌ | ✅ | Stake authority must sign |

## Arguments

None.

## Merge Compatibility

Both accounts must have:
- Same stake authority
- Same withdraw authority
- Same lockup parameters

### State Compatibility Matrix

| Source State | Destination State | Compatible? |
|--------------|-------------------|-------------|
| Inactive | Inactive | ✅ Yes |
| Inactive | Activating | ✅ Yes |
| Inactive | Active (same epoch) | ✅ Yes |
| Activating | Activating (same epoch) | ✅ Yes |
| Active | Active (same epoch) | ✅ Yes |
| Deactivating | * | ❌ No |
| * | Deactivating | ❌ No |

### Additional Requirements

When both accounts are delegated:
- Must be delegated to the same validator
- Must have the same activation epoch

## Examples

### TypeScript (web3.js v1)

```typescript
import {
  Connection,
  PublicKey,
  Transaction,
  StakeProgram,
  sendAndConfirmTransaction,
} from '@solana/web3.js';

const connection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');

const destinationStake = new PublicKey('...');
const sourceStake = new PublicKey('...');
const stakeAuthority = /* Keypair */;

const mergeIx = StakeProgram.merge({
  stakePubkey: destinationStake,
  sourceStakePubkey: sourceStake,
  authorizedPubkey: stakeAuthority.publicKey,
});

const tx = new Transaction().add(mergeIx);

const signature = await sendAndConfirmTransaction(connection, tx, [
  payer,
  stakeAuthority,
]);

console.log('Merge complete:', signature);
// Source account is now closed
// Destination account has combined balance
```

### TypeScript (@solana-program/stake)

```typescript
import { getMergeInstruction } from '@solana-program/stake';
import { 
  CLOCK_SYSVAR_ADDRESS, 
  STAKE_HISTORY_SYSVAR_ADDRESS 
} from '@solana/kit';

const mergeIx = getMergeInstruction({
  destinationStakeAccount: destinationStakeAddress,
  sourceStakeAccount: sourceStakeAddress,
  stakeAuthority: stakeAuthoritySigner,
  clock: CLOCK_SYSVAR_ADDRESS,
  stakeHistory: STAKE_HISTORY_SYSVAR_ADDRESS,
});
```

### Rust

```rust
use solana_sdk::{
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    stake::instruction as stake_instruction,
    transaction::Transaction,
};

fn merge_stakes(
    client: &RpcClient,
    payer: &Keypair,
    destination_stake: &Pubkey,
    source_stake: &Pubkey,
    stake_authority: &Keypair,
) -> Result<(), Box<dyn std::error::Error>> {
    let merge_ix = stake_instruction::merge(
        destination_stake,
        source_stake,
        &stake_authority.pubkey(),
    )[0].clone();

    let recent_blockhash = client.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &[merge_ix],
        Some(&payer.pubkey()),
        &[payer, stake_authority],
        recent_blockhash,
    );

    client.send_and_confirm_transaction(&tx)?;
    Ok(())
}
```

### CLI

```bash
# Merge source into destination
solana merge-stake <DESTINATION_STAKE_ADDRESS> <SOURCE_STAKE_ADDRESS>

# With explicit stake authority
solana merge-stake <DESTINATION_STAKE_ADDRESS> <SOURCE_STAKE_ADDRESS> \
  --stake-authority <STAKE_AUTHORITY_KEYPAIR>
```

## Checking Merge Eligibility

```typescript
async function canMerge(
  connection: Connection,
  destination: PublicKey,
  source: PublicKey,
): Promise<{ eligible: boolean; reason?: string }> {
  const [destInfo, srcInfo] = await Promise.all([
    connection.getParsedAccountInfo(destination),
    connection.getParsedAccountInfo(source),
  ]);

  const destData = destInfo.value?.data.parsed.info;
  const srcData = srcInfo.value?.data.parsed.info;

  // Check authorities match
  if (destData.meta.authorized.staker !== srcData.meta.authorized.staker) {
    return { eligible: false, reason: 'Stake authorities differ' };
  }
  if (destData.meta.authorized.withdrawer !== srcData.meta.authorized.withdrawer) {
    return { eligible: false, reason: 'Withdraw authorities differ' };
  }

  // Check lockup matches
  const destLockup = destData.meta.lockup;
  const srcLockup = srcData.meta.lockup;
  if (JSON.stringify(destLockup) !== JSON.stringify(srcLockup)) {
    return { eligible: false, reason: 'Lockup parameters differ' };
  }

  // Check activation states
  const [destActivation, srcActivation] = await Promise.all([
    connection.getStakeActivation(destination),
    connection.getStakeActivation(source),
  ]);

  if (destActivation.state === 'deactivating' || srcActivation.state === 'deactivating') {
    return { eligible: false, reason: 'Cannot merge deactivating stakes' };
  }

  // Check delegation matches if both are staked
  if (destData.stake && srcData.stake) {
    if (destData.stake.delegation.voter !== srcData.stake.delegation.voter) {
      return { eligible: false, reason: 'Delegated to different validators' };
    }
  }

  return { eligible: true };
}
```

## Errors

| Error | Cause |
|-------|-------|
| `MergeMismatch` | Accounts have different authorities or lockups |
| `InvalidAccountData` | One or both accounts not valid stake accounts |
| `MergeTransientStake` | Cannot merge deactivating stake |
| `NotDelegated` | Attempting to merge stakes with different validators |
